.TH "includes/minishell.h" 3 "Thu Jul 7 2016" "minishell" \" -*- nroff -*-
.ad l
.nh
.SH NAME
includes/minishell.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <unistd\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <sys/wait\&.h>\fP
.br
\fC#include <signal\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include 'libft\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBshell_loop\fP (int fd)"
.br
.ti -1c
.RI "int \fBparse_env_conf\fP (char *conffile)"
.br
.ti -1c
.RI "int \fBbi_cd\fP (char **av)"
.br
.ti -1c
.RI "int \fBbi_env\fP (char **av)"
.br
.ti -1c
.RI "int \fBbi_suenv\fP (char **av)"
.br
.ti -1c
.RI "void \fBsp_prompt\fP (void)"
.br
.ti -1c
.RI "int \fBexec_line\fP (char *line)"
.br
.ti -1c
.RI "int \fBcommand\fP (char *line, char **env, int bi)"
.br
.ti -1c
.RI "char * \fBin_path\fP (char *cmd, char *path)"
.br
.ti -1c
.RI "char * \fBcin_c2c\fP (char *c1, char **c2)"
.br
.ti -1c
.RI "void \fBsighandler\fP (int nb)"
.br
.ti -1c
.RI "int \fBforkexec\fP (char *cmd, char **av, char **env)"
.br
.ti -1c
.RI "char * \fBtr_eq\fP (char *s)"
.br
.ti -1c
.RI "int \fBin_builtins\fP (char **av)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "char ** \fBenviron\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int bi_cd (char ** av)"

.SS "int bi_env (char ** av)"

.SS "int bi_suenv (char ** av)"

.SS "char* cin_c2c (char * c1, char ** c2)"
Search for str c1 in strs table c2
.PP
Iter on c2 strs to find c1\&. Stop on first occurence of c1 in c2, or when NULL-terminating pointer has been reached in c2\&.
.PP
c1: Searched string  c2: Table of strings which may contains c1
.PP
\fBReturns:\fP
.RS 4
Pointer to c1 in c2, or NULL (reached end of c2 before finding c1) 
.RE
.PP

.SS "int command (char * line, char ** env, int bi)"

.SS "int exec_line (char * line)"
Slit string into commands and launch them
.PP
First if ';' in line, split into simpler commands lines, then exec it via \fBcommand()\fP
.PP
line: the string to be evaluated
.PP
\fBReturns:\fP
.RS 4
0 if line was NULL (CTRL-D ('EOF') was hit, shell quit), 1 else 
.RE
.PP

.SS "int forkexec (char * cmd, char ** av, char ** env)"

.SS "int in_builtins (char ** av)"

.SS "char* in_path (char * cmd, char * path)"
Try to find cmd in path
.PP
Longer desc \&.\&.\&.
.PP
cmd: command (binary) to search trought path  path: ':'-separated list of folders name
.PP
\fBReturns:\fP
.RS 4
Real path to cmd binary (ready to be passed to execve(), or NULL 
.RE
.PP

.SS "int parse_env_conf (char * conffile)"

.SS "void shell_loop (int fd)"
Shell main loop
.PP
Loop reading :
.IP "\(bu" 2
first the \fIfd\fP var, if not 0
.IP "\(bu" 2
second the \fI0\fP fd (standard input)
.PP
.PP
Try to exec each string (readed via \fBget_next_line()\fP) with \fBexec_line()\fP
.PP
fd: file descriptor, to a configuration/script file; or to the standard input (and THEN to the stdin)
.PP
\fBReturns:\fP
.RS 4
Dont return but can exit() 
.RE
.PP

.SS "void sighandler (int nb)"

.SS "void sp_prompt (void)"

.SS "char* tr_eq (char * s)"

.SH "Variable Documentation"
.PP 
.SS "char** environ"

.SH "Author"
.PP 
Generated automatically by Doxygen for minishell from the source code\&.
